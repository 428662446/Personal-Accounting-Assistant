类别管理设计2.0

迭代问题：
1. 是否允许用户手动管理Category？
可以
1.1 若允许手动DeleteCategory，原先的设置该类别账单如何处理？
前端向用户提示警告“删除该类别后，该类别的账单将会划分至未知”

√1. 新增Category的模型
1.1 ID
1.2 Name
1.3 Create_at

√2. 修改Transaction模型，从直接存储类别string到存储类别ID：Category  string `json:"category"`改为CategoryID  int64 `json:"category_id"`
(保持DisplayTransaction模型不变，仍为类别string，名字改为CategoryName)
	
3. 数据层：
√3.1 user_db文件，在createUserDatabase函数中，创建transactions表单的时候同时创建category表单且transaction的表单、涉及类别的地方都改过来
3.2 transaction：涉及类别的地方都改过来
√3.3 category：新增类别的CRUD的数据库操作、GetCategoryByID()
×3.4 transaction：GetTransactions()中t.Amount = utils.CentsToYuanString(cents)相关操作迁移至服务层
√3.5 新增UpdateTransactionCategoryIdToZero()
3.6 

4. 服务层：
√4.1.1 transaction：GetTransactions()中完成CentsToYuanString（不改了，不然在数据层CategoryID->CategorySTring又在服务层CentsToYuanString，各做一半，只能新建中间态模型，麻烦）

√4.1.2 transaction：GetTransactions()中完成CategoryID->CategorySTring（GetCategoryByID()）（改：在数据库中完成：JSIN在数据库查询时直接获取category name，避免N+1查询问题）

SELECT 
    t.id, t.type, t.amount, 
    COALESCE(c.name, '其他') as category_name,  -- 如果c.name为空，就显示'其他'
    t.note, t.created_at
FROM transactions t  -- t是transactions的别名
LEFT JOIN categories c ON t.category_id = c.id  -- 连接条件
ORDER BY t.created_at DESC  -- 按创建时间倒序


√4.1.3 且若ID为0，显示为“其他”
√4.2 新增GetCategory、CreateCategory、UpdataCategory服务
√4.3 新增DeletedCategory、同时查找是否有该类别账单，将这些账单的类别ID设置为0（改在数据库完成，用事务确保数据一致性
）

5. 控制？层：
5.1 新增ReadCategory、DeletedCategory、CreateCategory、UpdataCategory响应方法

回复AI建议以及AI对应回复：

1. transaction也没有存储用户信息（UserID），因为现在的架构transaction有关服务都是TransactionService的方法会关联到一个主数据库，且会通过会话、中间件获取上下文中的用户ID，我可能说的不准确，但是这样应该足够实现关联用户信息隔离，Category模型应该同样不需要userID

你说得对！在当前架构下，每个用户有自己的数据库，所以Transaction和Category都不需要存储user_id，因为数据天然隔离。这个设计很合理。


2. 关于“master数据库：不需要存放category表，每个用户的category应该存在各自的用户数据库中”，我打错字了应该是user_db文件，在createUserDatabase函数中，创建transactions表单的时候同时创建category表单

3. 关于“GetTransactions修改：建议在数据库层做JOIN查询，而不是在服务层多次查询”，我还没想好怎么完成且高效“同时查找是否有该类别账单，将这些账单的类别ID设置为0

4. 关于“4.1.2 CategoryID转String：在数据库查询时直接获取category name，避免N+1查询问题”，没听懂，什么是N+1

N+1查询是个重要的性能概念：
问题场景：
go
// 伪代码 - 有N+1问题的写法
transactions := GetTransactions() // 1次查询
for _, t := range transactions {
    category := GetCategoryByID(t.CategoryID) // N次查询
    // 总共执行了 1 + N 次数据库查询
}
优化方案：
sql
-- 1次查询搞定所有数据
SELECT 
    t.id, t.type, t.amount, 
    COALESCE(c.name, '其他') as category_name,
    t.note, t.created_at
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
ORDER BY t.created_at DESC
这样在数据库层面一次性完成所有数据的获取，性能好很多。

5. 关于“4.3 删除类别：建议用事务确保数据一致性”，(´。＿。｀)（*゜ー゜*）

你的思路是对的！在事务中执行：
在事务中执行：
sql
-- 1. 先更新所有使用该类别的交易
UPDATE transactions SET category_id = 0 WHERE category_id = ?;
-- 2. 再删除类别
DELETE FROM categories WHERE id = ?;

6.关于“数据迁移”，没有任何需要留下的数据


7. 我想不明白，类别为什么需要区分是"income"还是"expense"的，金额统计总数又不需要类别，类别统计的时候，可以先按类别划分账单，然后根据账单type再划分账单，为什么需要到类别的类型

你的观点很有道理！确实，从技术角度：
统计总收入/支出不需要知道类别类型
类别统计时可以根据交易的type来区分
但考虑用户体验：
用户记录收入时，只看到"收入类别"（如：工资、奖金）
用户记录支出时，只看到"支出类别"（如：餐饮、交通）
避免用户选错（比如把"餐饮"选成收入类别

——好有道理，但是觉得好麻烦，还要在技术层面防止用户把income类型的标签设置到expense类型的账单里（否则以后如果根据Category的Type做扩展功能的话就容易出问题）
而且我觉得更有可能的情况是，用户可能也会莫名其妙为什么，我就是想把我的收入，划分成来自“清洁”、“餐饮”、“家教”啊，我都新建一个“餐饮”标签了（即使前端可能会同时给出两个表income/expense）为什么选不了/没有/还得再写一个

结论：不区分

8. 关于初始化标签讨论结论

服务层提供常用类别推荐
go
// 在获取类别列表时，如果没有自定义类别，返回推荐列表
func (s *CategoryService) GetCategories(userID int64) ([]Category, error) {
    userDB, err := database.GetUserDB(userID)
    if err != nil {
        return nil, err
    }
    defer userDB.Close()
    
    // 获取用户自定义类别
    categories, err := database.GetCategories(userDB)
    if err != nil {
        return nil, err
    }
    
    // 如果用户没有自定义类别，返回推荐列表（但不保存到数据库）
    if len(categories) <= 1 { // 只有"其他"
        return []Category{
            {ID: 0, Name: "其他"},
            {ID: -1, Name: "餐饮"},  // 负ID表示推荐类别
            {ID: -2, Name: "交通"},
            {ID: -3, Name: "购物"},
        }, nil
    }
    
    return categories, nil
}
